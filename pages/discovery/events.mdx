---
title: List Events
description: Discover canonical events (sports, politics, macro, etc.) with venue-native IDs for accessing Polymarket and Kalshi APIs.
---

# List Events

> **GET `/v1/events`** — Discover canonical events across venues. Each event can map to multiple venue-native IDs and contains one or more markets.

- **Base URL:** `https://api.predexon.com/v1`
- **Auth:** `Authorization: Bearer <token>`
- **Time:** All timestamps are **UTC ISO-8601** (e.g., `2025-10-06T19:21:02Z`)
- **Pagination:** Cursor-based via `next_cursor` (no `prev_cursor`)
- **Rate Limits:** 100 requests/minute per API key. Returns `429` with `Retry-After` header when exceeded.

## Common use cases

- **Sports on a date:** MLB games on `2025-07-12`
- **Upcoming elections:** US elections with `event_status=scheduled`
- **Macro releases:** Find CPI/Fed events for a specific date

## Endpoint

```http
GET /v1/events
```

## Query parameters

All are optional unless noted.

| Parameter | Type | Notes |
|-----------|------|-------|
| `category` | string | Hierarchical path (e.g., `sports/baseball/mlb`, `politics/elections/us`). Can query at any level. Categories are returned in event responses. |
| `event_status` | enum | `scheduled` \| `live` \| `resolved` \| `cancelled`. Filter by event lifecycle state. |
| `date` | string | UTC date `YYYY-MM-DD`. Returns events scheduled on this date (based on `scheduled_start` field). |
| `participant` | string | Participant identifier returned in event `participants[]` array. Case-insensitive substring match. Examples: `NYY`, `BOS`, `TRUMP`. |
| `event_uid[]` | string[] | Fetch specific events by canonical ID. Repeatable. Use when you already have event IDs from a previous call. |
| `venue` | enum | `POLYMARKET` \| `KALSHI`. Returns events that exist on the specified venue (have entries in `venue_ids`). |
| `polymarket_slug[]` | string[] | Polymarket event slug (from `venue_ids.polymarket[]`). Format: lowercase-hyphenated (e.g., `nfl-buf-kc-2025-01-26`). Repeatable. |
| `kalshi_event_ticker[]` | string[] | Kalshi event ticker (from `venue_ids.kalshi[]`). Format: uppercase alphanumeric (e.g., `KXNFLGAME-25JAN26BUFKC`). Repeatable. |
| `limit` | integer | Results per page. Default: 50, max: 200. |
| `cursor` | string | Opaque pagination cursor from previous response's `next_cursor`. |

<Info>
**Query behavior:**

- **No parameters:** Returns all events (paginated), ordered by `scheduled_start` descending, then by `event_uid` ascending for same-timestamp events.
- **Multiple parameters:** Combined with AND logic. Example: `category=sports&date=2025-07-12` returns sports events on that date only.
- **Array parameters:** OR logic within the array. Example: `event_uid[]=evt_1&event_uid[]=evt_2` returns both events.
- **Participant search:** Case-insensitive substring match. `participant=LA` matches `LAL`, `LAC`, `LAD`. Matches anywhere in participant code.
</Info>

<Info>
**Where do IDs come from?**

- **Categories & participants:** Returned in event responses. Use List Events to discover available values, then filter by them.
- **Polymarket slugs:** Get from Polymarket's `/events` API or from previous Discovery API calls in `venue_ids.polymarket[]`.
- **Kalshi tickers:** Get from Kalshi's `/events` API or from previous Discovery API calls in `venue_ids.kalshi[]`.
- **event_uid:** Returned in all Discovery API responses. Store these for lookups.

**Common pattern:** Call List Events with broad filters (`category` + `date`), then use returned `event_uid` or `venue_ids` for subsequent specific queries.
</Info>

## Response schema

```json
{
  "events": [
    {
      "event_uid": "evt_nfl_2025_01_26_BUF_KC",
      "title": "BUF vs KC",
      "category": "sports/football/nfl",
      "scheduled_start": "2025-01-26T18:30:00Z",
      "event_status": "scheduled",
      "participants": ["BUF", "KC"],
      "venue_ids": {
        "polymarket": ["nfl-buf-kc-2025-01-26"],
        "kalshi": ["KXNFLGAME-25JAN26BUFKC"]
      },
      "asof": "2025-01-20T14:22:33Z"
    }
  ],
  "next_cursor": "eyJpZCI6MTIzNDU2fQ"
}
```

## Field reference

| Field | Type | Description |
|-------|------|-------------|
| `event_uid` | string | Canonical, stable event identifier |
| `title` | string | Human-readable event title |
| `category` | string | Taxonomy path (e.g., `sports/baseball/mlb`) |
| `scheduled_start` | string (ISO-8601) | Scheduled UTC start timestamp |
| `event_status` | enum | Lifecycle: `scheduled`, `live`, `resolved`, `cancelled` |
| `participants` | string[] | Simple codes (teams, candidates, etc.) |
| `venue_ids` | object | Venue-native identifiers for this event. Contains `polymarket` and `kalshi` arrays. Empty arrays (`[]`) indicate event not available on that venue. |
| `venue_ids.polymarket` | string[] | Polymarket event slugs (use with `/events/slug/{slug}` endpoint). Empty if not on Polymarket. |
| `venue_ids.kalshi` | string[] | Kalshi event tickers (use with `/events/{event_ticker}` endpoint). Empty if not on Kalshi. |
| `asof` | string (ISO-8601) | Timestamp when this event data was captured. Changes when event details are updated (status, participants, venue mappings). Use for cache invalidation. |
| `next_cursor` | string | Cursor for the next page (omit when last page) |

## Examples

<CodeGroup>

```bash cURL
# 1) MLB events on a specific date
curl -s -H "Authorization: Bearer $PREDX_TOKEN" \
  "https://api.predexon.com/v1/events?category=sports/baseball/mlb&date=2025-07-12&limit=100"

# 2) US elections that are scheduled (not started)
curl -s -H "Authorization: Bearer $PREDX_TOKEN" \
  "https://api.predexon.com/v1/events?category=politics/elections/us&event_status=scheduled"

# 3) Fetch multiple events by canonical IDs (array syntax)
curl -s -H "Authorization: Bearer $PREDX_TOKEN" \
  "https://api.predexon.com/v1/events?event_uid[]=evt_mlb_2025_07_12_NYY_BOS&event_uid[]=evt_mlb_2025_07_12_LAD_SF"

# Alternative: repeated parameter syntax (same result)
curl -s -H "Authorization: Bearer $PREDX_TOKEN" \
  "https://api.predexon.com/v1/events?event_uid=evt_mlb_2025_07_12_NYY_BOS&event_uid=evt_mlb_2025_07_12_LAD_SF"

# 4) Pagination: fetch the next page using next_cursor
curl -s -H "Authorization: Bearer $PREDX_TOKEN" \
  "https://api.predexon.com/v1/events?cursor=eyJpZCI6..."
```

```javascript JavaScript
// Node 18+ (fetch)
const base = "https://api.predexon.com/v1";
const headers = { Authorization: `Bearer ${process.env.PREDX_TOKEN}` };

async function listMlbByDate() {
  const url = new URL(`${base}/events`);
  url.searchParams.set("category", "sports/baseball/mlb");
  url.searchParams.set("date", "2025-07-12");
  url.searchParams.set("limit", "100");

  const res = await fetch(url, { headers });
  if (!res.ok) throw new Error(`${res.status} ${await res.text()}`);
  const data = await res.json();
  return data.events;
}
```

```python Python
import os, requests

BASE = "https://api.predexon.com/v1"
HEADERS = {"Authorization": f"Bearer {os.environ['PREDX_TOKEN']}"}

def list_us_elections_scheduled():
  params = {
    "category": "politics/elections/us",
    "event_status": "scheduled"
  }
  r = requests.get(f"{BASE}/events", headers=HEADERS, params=params, timeout=30)
  r.raise_for_status()
  return r.json()["events"]
```

```go Go
package main

import (
  "encoding/json"
  "fmt"
  "net/http"
  "net/url"
  "os"
)

func main() {
  q := url.Values{}
  q.Set("category", "macro/cpi")
  q.Set("date", "2025-10-14")

  req, _ := http.NewRequest("GET", "https://api.predexon.com/v1/events?"+q.Encode(), nil)
  req.Header.Set("Authorization", "Bearer "+os.Getenv("PREDX_TOKEN"))

  res, err := http.DefaultClient.Do(req)
  if err != nil { panic(err) }
  defer res.Body.Close()

  var out struct {
    Events     []any  `json:"events"`
    NextCursor string `json:"next_cursor"`
  }
  json.NewDecoder(res.Body).Decode(&out)
  fmt.Println("events:", len(out.Events), "next_cursor:", out.NextCursor)
}
```

</CodeGroup>

## Errors

All errors return standard HTTP status codes with JSON error responses:

```json
{
  "error": {
    "type": "invalid_parameter",
    "message": "date must be in YYYY-MM-DD format",
    "param": "date"
  }
}
```

**Empty results** return HTTP 200 with empty array:

```json
{
  "events": [],
  "next_cursor": null
}
```

See [Errors & Status Codes](/support/errors) for full list and remediation tips.

## Best practices

1. **Daily scans:** Query with `category` + `date` filters. Store each event's `event_uid` (for future lookups) and `asof` timestamp (to detect when event data changes).

2. **Change detection:** Re-fetch with `event_status` filters to catch postponements/cancellations.

3. **Cursor loops:** Continue until `next_cursor` is absent.

4. **Access venue APIs:** Extract `venue_ids.polymarket` or `venue_ids.kalshi` to call venue-specific endpoints for orderbooks, trade execution, or liquidity data.

5. **Caching:** Cache by querystring and invalidate when `asof` changes.

## Related

- [List Markets](/pages/discovery/markets) — Markets under each event
- [Market Detail](/pages/discovery/market-detail) — Rules, fees, and resolution text
- [Matching Markets](/pages/discovery/matching) — Map venue selectors to canonical IDs
